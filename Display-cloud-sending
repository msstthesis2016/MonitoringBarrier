// smart barrier for msst2016 thesis
// hatran3e
#include <NewPing.h>
#include "SSD1306.h" // OLED library
#include <WiFi.h>
#include <WiFiMulti.h> // Multi AP
#include <IOXhop_FirebaseESP32.h>

//set config for sonar sensors
#define SONAR_NUM 3      // Number of sensors.
#define MAX_DISTANCE 400 // Maximum distance  cm
#define MIN_DISTANCE 3  // Minimum distance  cm
#define max_sample 20 // Maximum sample

//display or clear text on LCD 1/0: display/clear
#define PIR 1
#define RADAR 1
#define SONAR 1

// sending to cloud
#define CLOUD 1

//geting time 
#define TIME 1

// AP list
#define AP1 "AP1"
#define PW1 "PW1"
#define AP2 "AP2"
#define PW2 "PW2"
#define AP3 "AP3"
#define PW3 "PW3"

// Set these to send data
#define FIREBASE_HOST "yourhost.firebaseio.com"
#define FIREBASE_AUTH "yourkey"

// define pins
#define PIN_RADAR1 17
#define PIN_RADAR2 35
#define PIN_RADAR3 39

#define PIN_PIR1 34
#define PIN_PIR2 25
#define PIN_PIR3 2
//Ultra Sonic
#define trig50 13 
#define echo50 36

#define trig100 21
#define echo100 37

#define trig150 22
#define echo150 38

// define OLED display config
#define SDA    4
#define SCL   15
#define RST   16 //RST must be set by software
SSD1306  display(0x3c, SDA, SCL, RST);


const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 3600;
const int   daylightOffset_sec = 3600;



WiFiMulti wifiMulti;
typedef struct Data_Fire{
    int D1;
    int D2;
    int D3;
    bool R1;
    bool R2;
    bool R3;
    bool P1;
    bool P2;
    bool P3;
} Data_Fire;

Data_Fire Fire_store;

NewPing sonar[SONAR_NUM] = {   // Sensor object array.
  NewPing(trig50, echo50, MAX_DISTANCE), // Each sensor's trigger pin, echo pin, and max distance to ping. 
  NewPing(trig100, echo100, MAX_DISTANCE), 
  NewPing(trig150, echo150, MAX_DISTANCE)
};

//variables used in program
long  distance50, distance100, distance150;
int i;
int n = 0;
struct tm timeinfo;

void printLocalTime()
{
  
  if(!getLocalTime(&timeinfo)){
    Serial.println("Failed to obtain time");
    return;
  }
  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
}


void drawText(int x, int y, char* input_text ) {
    display.setTextAlignment(TEXT_ALIGN_LEFT);
    display.setFont(ArialMT_Plain_10);
    display.drawString(x, y, input_text);
    
}

void setup() {
  
  //set up IO
  pinMode(PIN_RADAR1, INPUT);
  pinMode(PIN_RADAR2, INPUT);
  pinMode(PIN_RADAR3, INPUT);
  
  pinMode(PIN_PIR1,INPUT);
  pinMode(PIN_PIR2,INPUT);
  pinMode(PIN_PIR3,INPUT);

  //set up LCD
  pinMode(16,OUTPUT);
  digitalWrite(16, LOW);    // set GPIO16 low to reset OLED
  delay(50); 
  digitalWrite(16, HIGH); // while OLED is running, must set GPIO16 in high
  Serial.begin(115200);
  Serial.println();
  Serial.println();
  display.init();

  display.flipScreenVertically();
  display.setFont(ArialMT_Plain_10);

  wifiMulti.addAP(AP1, PW1);
  wifiMulti.addAP(AP2, PW2);
  wifiMulti.addAP(AP3, PW3);


  // connect to wifi.
//  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
//  Serial.print("connecting");
//  while (WiFi.status() != WL_CONNECTED) {
//    Serial.print(".");
//    delay(500);
//  }

  Serial.println("Wait for connecting Wifi...");
  delay(500);
  if(wifiMulti.run() == WL_CONNECTED) {
    Serial.println();
    Serial.println("WiFi connected");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());

    Firebase.begin(FIREBASE_HOST, FIREBASE_AUTH);
  }
  else
  {
    Serial.println("WiFi not connected!");
    while(WiFi.status() != WL_CONNECTED)
    {
      Serial.println("Reconnecting wifi...");
      display.drawString(0, 0, "Reconnecting wifi...");
      delay(200);
      if(wifiMulti.run() == WL_CONNECTED)
      {
        Serial.println("");
        Serial.println("WiFi connected");
        Serial.print("IP address: ");
        Serial.println(WiFi.localIP());
        break;
      }
    }
  }
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  printLocalTime();
  
}

void loop() {

  display.clear ();
  int R1 = digitalRead(PIN_RADAR1);
  int R2 = digitalRead(PIN_RADAR2);
  int R3 = digitalRead(PIN_RADAR3);
  
  int PIR1 = digitalRead(PIN_PIR1);
  int PIR2 = digitalRead(PIN_PIR2);
  int PIR3 = digitalRead(PIN_PIR3);   
  
#if(TIME)
  if(!getLocalTime(&timeinfo)) // get timeinfo
  {
    Serial.println("Failed to obtain time"); 
  }
  else
  {
	Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
	// drawText(0,30,String(timeinfo.tm_hour));
	Serial.println(timeinfo.tm_hour);
	// drawText(0,30,String(timeinfo));
  }
  

#endif
  
#if(SONAR)
  //Ultrasonic 1
  for( i = 0; i<max_sample; i++)
  {
	  delay(30); // Wait 50ms between pings (about 20 pings/sec). 29ms should be the shortest delay between pings.
	  distance50 += sonar[0].ping_cm();
  }
  
  distance50 = distance50/max_sample; //avarage distance
  
  if (distance50 < MIN_DISTANCE) { 
//      display.drawString(0, 30, "Too close"); 
      drawText(0,30,"Too close");
      Serial.println("Sensor1: Too close");
  }
  else if (distance50 > MAX_DISTANCE || distance50 <= MIN_DISTANCE){
		drawText(0,30,"Out of range");
		Serial.println("Sensor1: Out of range");
  }
  else {
		display.drawString(60, 30, String(distance50) + " cm");
		display.display();
		Serial.print("Sensor1: ");
		Serial.print(distance50);
		Serial.print(" cm   ");
  }
  
  //Ultrasonic 2
  for( i = 0; i<max_sample; i++)
  {
	  delay(30); // Wait 50ms between pings (about 20 pings/sec). 29ms should be the shortest delay between pings.
	  distance100 += sonar[0].ping_cm();
  }
  
  distance100 = distance100/max_sample;  //avarage distance

  if (distance100 < MIN_DISTANCE) {  
     drawText(0,40,"Too close");
     Serial.println("Sensor2: Too close");
  }
  else if (distance100 > MAX_DISTANCE || distance100 <= MIN_DISTANCE){
    drawText(0,40,"Out of range");
    Serial.println("Sensor2: Out of range");
  }
  else {
    display.drawString(60, 40, String(distance100) + " cm");
    display.display();
    Serial.print("Sensor2: ");
    Serial.print(distance100);
    Serial.print(" cm  ");
  }
  
  // Utrasonic 3
  for( i = 0; i<max_sample; i++)
  {
	  delay(30); // Wait 50ms between pings (about 20 pings/sec). 29ms should be the shortest delay between pings.
	  distance150 += sonar[0].ping_cm();
  }
  
  distance150 = distance150/max_sample; //avarage distance

  if (distance150 < MIN_DISTANCE) {  
     drawText(0,50,"Too close");
     Serial.println("Sensor3: Too close");
  }
  else if (distance150 > MAX_DISTANCE || distance150 <= MIN_DISTANCE){
    drawText(0,50,"Out of range");
    Serial.println("Sensor3: Out of range");
  }
  else {
    display.drawString(60, 50, String(distance150) + " cm");
    display.display();
    Serial.print("Sensor3: ");
    Serial.print(distance150);
    Serial.print(" cm");
    Serial.println(" ");
  }
  delay(500);//delay before display
#endif

#if(RADAR)
  // Radar 1
  if (R1 == HIGH) {
    drawText(0,0,"R1 YES");
    display.display();
    Serial.println("R1 YES");
  }
  else {
	  drawText(0,0,"R1 NO");
	  display.display();
	  Serial.println("R1 NO");
  }

  // Radar 2
  if (R2 == HIGH) {
    drawText(0,10,"R2 YES");
    display.display();
    Serial.println("R2 YES");
  }
  else {
	  drawText(0,10,"R2 NO");
	  display.display();
	  Serial.println("R2 NO");
  }
  
  //Radar 3
  if (R3 == HIGH) {
    drawText(0,20,"R3 YES");
    display.display();
    Serial.println("R3 YES");
  }
  else {
	  drawText(0,20,"R3 NO");
	  display.display();
	  Serial.println("R3 NO");
  } 
  delay(500); //delay before display 
  #endif
	Serial.println();
#if(PIR)
  
  if(PIR1 == HIGH)
  {
    drawText(60, 0, "P1 YES");
    display.display();
    Serial.println("P1 YES");
  }
  else
  {
    drawText(60, 0, "P1 NO");
    display.display();
    Serial.println("P1 NO");
  }

  if(PIR2 == HIGH)
  {
    drawText(60, 10, "P2 YES");
    display.display();
    Serial.println("P2 YES");
  }
  else
  {
    drawText(60, 10, "P2 NO");
    display.display();
    Serial.println("P2 NO");
  }

  if(PIR3 == HIGH)
  {
    drawText(60, 20, "P3 YES");
    display.display();
    Serial.println("P3 YES");
  }
  else
  {
    drawText(60, 20, "P3 NO");
    display.display();
    Serial.println("P3 NO");
  }
  delay(500);//delay before display
  
  #endif

#if(CLOUD)
  
  // set value
  Firebase.setFloat("Distance50", distance50);
  Firebase.setFloat("Distance100", distance100);
  Firebase.setFloat("Distance150", distance150);
  Firebase.setBool("R1",R1);
  Firebase.setBool("R2",R2);
  Firebase.setBool("R3",R3);
  Firebase.setBool("P1",PIR1);
  Firebase.setBool("P2",PIR2);
  Firebase.setBool("P3",PIR3);
  // handle error
  if (Firebase.failed()) {
      Serial.print("setting /number failed:");
      Serial.println(Firebase.error());  
      return;
  }
  delay(1000);
  

  // get value 
  Serial.print("distance50: ");
  Serial.println(Firebase.getFloat("distance50"));
  delay(500);

  
  // handle error
  if (Firebase.failed()) {
      Serial.print("setting /truth failed:");
      Serial.println(Firebase.error());  
      return;
  }
  delay(1000);

  // append a new value to /logs
  String name = Firebase.pushInt("logs", n++);
  // handle error
  if (Firebase.failed()) {
      Serial.print("pushing /logs failed:");
      Serial.println(Firebase.error());  
      return;
  }
  Serial.print("pushed: /logs/");
  Serial.println(name);
  delay(1000);
  
#endif
  
}

